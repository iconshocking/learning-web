# Django Notes

## Standard Django project structure:

Do NOT put your project in the web server document root to avoid accidental exposure of your code to
the web.

Django automatically adds the project root to sys.path, so you can import from apps/packages across the project

```
- project-name (this can be renamed after creation)
    - manage.py (django manager script for commands within a project)
    - project-name/ (files generated by 'djangoadmin' setup that apply to the entire site)
        - settings.py (settings for the entire project)
        - urls.py (for routing to different applications)
        - wsgi.py (Web Server Gateway Interface - entry point for the web site and interface for web server interaction, where requests come in from)
        - asgi.py (Asynchrounous Server Gateway Interface - the difference here is that IO is not process-blocking, so changes of 1-1 proccess-to-request to 1-to-many)
        - __init__.py (defines the directory as a python package, but might be optional for Python 3.3+)
    - app1/ (the applications that constitute a web site)
    - app2/ (these are different areas of the site, promoting reusability where a singular application can be ported to multiple projects)
    - app3/
        - __init__.py (again, makes dir a package)
        - views.py
        - models.py
        - forms.py
        - apps.py (application registration)
        - admin.py (for admin site configuration)
        - tests/ (default discovery will find any file of format 'test*.py' as a test, but usually create a dir for organization)
          - __init__.py (required for django to recognize package when calling 'test' command)
          - test_[xxx].py
        - migrations/ (updated each time you run `makemigration`)
        - templates/
            - app3/ (this dir prevents name collision since page.html is ambiguous to django if app2 also contains a page.html, whereas app3/page.html is not)
                - page.html
            - admin/
                - app3/ (where to put default admin template overrides)
                    - change_form.html
                    - modelname/
                        - change_form.html (overrides only for that model)
        - static/ (assets - CSS, JS, images, etc.)
            - app3/ (again, avoid name collision)
    - templates/ (top-level templates, though much shouldn't need to live here vs having a 'core' app to house common templates)
        - registration/  (no nested app directory if you want default auth template overrides)
          - login.html
    - static/ (ditto)
```

NOTE: Project-level templates/statics will not be discovered unless their dirs are added to `TEMPLATES`' `DIRS` / `STATICFILES_DIRS`.

This can be expanded upon with modules, where if the views/models/test file for a particular app
becomes too large, convert to something like the following:

```
- app/
    - views/
        - __init__.py
        - view_a.py
        - view_b.py
        ...
    - models/
        - ...
    - test/
        - ...
```

`__init__.py` can then export views from the top-level of the package (ex: `from .view_a import
ViewA`). This avoids needing to refactor any imports.

## General Commands

### Setup

- `django-admin startproject [project-name]` creates the initial project directory (manage.py and
  everything in the project-name subdirectory)

- `python manage.py startapp [appName]` creates an application with the default struture listed
  above

  - To configure as a project app, add `appName.apps.[AppNameConfig]` to `INSTALLED_APPS` in the
    project `settings.py`
    - `INSTALLED_APPS` and `MIDDLEWARE` will already have apps installed, which are for the admin
      site

- BEFORE RUNNING ANY MIGRATIONS OR CREATING USERS, create a custom User model and point to it with `AUTH_USER_MODEL`. This is _very_ difficult to change after project creation.

- `python manange.py createsuperuser` allows for creating admin accounts

- `python manage.py runserver [ip]:[port]` runs the development server at \[ip\]:\[port\] with auto
  reloading, though those arguments are optional.

- `python manage.py shell` opens the python shell with `DJANGO_SETTINGS_MODULE` set to the project
  settings file, so this can be good for doing some quick testing/debugging.

- `python3 manage.py check --deploy` checks a variety of usual suspects for configurations that should change before being deployed to production.

#### Auto-documentation

Django supports an auto-documentation portion of the admin site at `admin/docs`:

1. Add `django.contrib.admindocs` to your `INSTALLED_APPS`.
2. Add `path('admin/doc/', include('django.contrib.admindocs.urls'))` to your `urlpatterns`. Make
   sure it’s included before the `'admin/'` entry, so that requests to /admin/doc/ don’t get handled
   by the latter entry.
3. Install the `docutils` package.
4. Optional: Using the admindocs bookmarklets requires
   `django.contrib.admindocs.middleware.XViewMiddleware` to be added to `MIDDLEWARE`.
   - Bookmarklets are browser bookmarks where the URL is instead Javascript that is executed when clicked.

View documentation comes from docstrings: look at `catalog.views.BookDetailView` for an example

Model documentation comes from docstrings, docstrings on its methods, and `help_text` on fields.

Only provided bookmarklet jumps to the documentation page for the view.

### Migrations

- `python manage.py makemigrations` creates new migration definitions according to changes in the
  models (must provide `[appName]` argument the first time to create the `migrations` folder if it
  doesn't exist)

- `python manage.py migrate` un/applies migrations

  - which migrations have been applied is stored in the `django_migrations` table

- `python manage.py sqlmigrate [app] [migration]` displays the SQL statements that will be run for a
  migration

- `python manage.py showmigrations` list migrations and their status where `[X]` refers to an
  applied migration

## settings.py

- `DEBUG` - ALWAYS MUST BE SET TO `False` IN PRODUCTION
- `SECRET_KEY` - DO NOT HARDCODE OR CHECK INTO VERSION CONTROL
- `INSTALLED_APPS` - registered applications for the project
  - When setting a custom admin site, you can disable `autodiscover()` (which searches and runs each
    app's `admin.py` files), in cases where you are registering them directly within the admin
    site's by setting `django.contrib.admin.apps.SimpleAdminConfig` instead of
    `django.contrib.admin`
- `MIDDLEWARE` - middleware that intercepts requests/responses
- `TEMPLATES` - HTML template options (such as directories) w/ support for different engines
- `DATABASES` - Database config
- `CACHES` - Cache config
- `AUTH_PASSWORD_VALIDATORS` - Validators to be run against passwords in order to meet a minimum
  strength threshold
- `DEFAULT_AUTO_FIELD` - Default primary key field type for models that do not define one
- `STATIC_URL` - Directory for static resources (CSS, JS, images, etc.)
- `USE_TZ/TIME_ZONE`
  - When enabled (default):
    - Stores datetime info in UTC in the DB (ONLY true for PostgreSQL)
      - Thus, if using another DB vendor, you MUST convert your timestamps if changing these values
    - Internal runtime datetime objects are time-zone-aware
    - Form/template datetime info is translated to the time-zone of the request
  - When disabled (not recommended), internal runtime datetime objects will use the server's
    physical location to naively set the time zone

## Urls

Generally referred to as the URLconf (configuration).

NOTE: ALWAYS end Django URLS with a slash. A URL with and without a trailing slash are different URLS (by search engines, by default file structure, etc.). For end-user convenience, Django appends a trailing slash to a URL missing one that failed to match any paths in the URLConf, and matches against the appended URL, redirecting if a match is found. (Can disable via `APPEND_SLASH` but NOT recommended.)

- NOTE: POST requests are turned into GET requests when redirected via 301/302, so to avoid this issue via typos, always construct URLs via reverse URLConf lookup instead of hardcoding.

In `project_name/urls.py`, define `urlpatterns` routes to either a view (function or class-based) or
an application's `urls.py`.

- NOTE: Routes do not match against query parameters since the start of the query (`?`) is considered the end of the navigation portion of the URL.

  - Use the `GET` attribute on the request object to get query parameters in the view.
  - General recommendation is to encode naviagation information into the pre-query portion of the
    URL, instead of relying on parameters.

- NOTE: forwarded routes via `include()` strip the matched part of the URL (so `app/something`
  becomes `something/` when forwarded to `app.urls`)

All routes are according to `ROOT_URLCONF` defined in `settings.py`, so to have multiple sub/domains
across a single project:

1. Multiple settings files need to defined
2. Multiple instances of the Django project need to be started
3. The environment variable `DJANGO_SETTINGS_MODULE` needs to be pointed to each settings file for
   each instance
4. Each instance must be running on a different port, which can be routed to by your web server.

Django serves default HTTP error pages (404, 500, 403, 400), but these can be configured by setting
`handler[XXX]`.

## Admin

- `admin.site.register(ModelClass, ModelAdmin)` (or `@admin.register(ConcreteOfAbstractModel)` for
  `class ModelAdmin` definition) will register each model's DB table to be accessible from the admin
  site along with any configurations defined in the ModelAdmin subclass.

- Admin templates can be overriden by putting templates in `templates/admin/app/[modelname]`, where
  `[modelname]` can be ommitted to apply template for all models in the app.

  - Rather than completely overriding by copy-pasting and making changes, it is recommended to
    extend from the admin templates via `{% extends "admin/[view].html %}` and override the desired
    block in the template.

- Theming can be overriden via creating an `admin/base.html` file.

- Can add password reset out of the box with `PasswordResetView` and associated views.

## MVC Architectures in Django

Django uses Model-View-Controller (MVC) architecture to structure the site, except the names are
actually map to MVT:

- Model = Model (the data)
- Template = View (the presentation)
- View = Controller (the business logic)

### Models

Define your models in `app/models.py`.

Note that any option starting with `db_` reflects in the DB table as the source of truth BEFORE any
model object ingestion of the record.

#### Querying Models

Model querying is performed through managers. Models can have multiple custom managers defined, but the default manager is retrieved via `ModelName.objects`.

A `QuerySet` is retrieved by calling any querying method on a manager (ex.: `ModuleName.objects.all()`).

- A `QuerySet` does not actaully query the DB UNTIL elements need to evaluted, so iteration,
  `len()`, `bool()`, `repr()` / printing, etc. (NOT slicing, as long as there is not a step
  argument).

- `QuerySet.filter(field_name__iequals/istartswith/etc="something")` queries the DB according to the filter, where double underscore separates the field name from the filter type

  - Can filter via related models via double underscore separator, which can even be chained (ex: `QuerySet.filter(foreign_key_field__id__equals="5"`)

- `QuerySet.explain()` states the details of how the query will be performed and its performace
  (reaults are specifc to the database that is set up for the model)

### Views

Views can be either function-based (FBVs) or class-based (CBVs), with various pros/cons:

- Functions: simpler and explicit but more boiler-plate and writing from scratch
- Classes: More concise with more capability out-of-the-box and extensible via subclassing and
  multiple inheritance, but some of the abstracted logic that is normally explicitly written in
  functions can cause confusion

  - https://ccbv.co.uk/ is a great reference

#### render() vs TemplateResponse()

Calling the `render()` shortcut generates an `HTTPResponse` from a request, template, and context. However, `HTTPResponse` is static and already rendered.

If you want to be able to edit the context of a response or even change the template for a response before it is rendered, return `TemplateResponse` from your view function/class (any class that uses a template by default will do this already).

`TemplateResponse` will not be rendered _usually_ until after passing through all template response middleware, but rendering can happen earlier if its `render()` function is manually called or its `content` attribute is manually set.

NOTE: Setting `.content` overrides any previous rendering whereas calling `render()` does nothing after the first render.

You can use `add_post_render_callback()` function from `TemplateResponse` if you want to apply a decorator vs a global response middleware.

#### Middleware

Middleware can intercept either requests or responses.

- For the _requests_ phase, they run in the order they are listed in `MIDDLEWARE` in settings.
- For the _responses_ phase, they run in reverse (since the middleware is a full requeset-response wrapper)

NOTE: Context processors are ALWAYS invoked unlike middleware, which can be short-circuited, so do NOT rely on middleware to provide REQUIRED context data.

Middleware can be defined two ways (`MiddlewareMixin` is DEPRECATED):

1. A function decorator like the following:

```
def simple_middleware(get_response):
    # One-time configuration and initialization.
    def middleware(request):
        # Code to be executed before the view (and later middleware) are called.
        response = get_response(request)
        # Code to be executed after the view response is received
        return response
    return middleware
```

2. A class like the following:

```
class SimpleMiddleware(object):
    def __init__(self, get_response):
        self.get_response = get_response # store response
        # One-time configuration and initialization.

    def __call__(self, request):
        response = self.get_response(request)
        return response

    # additional functionality supported by class middleware
    def process_view(request, view_func, view_args, view_kwargs):
        # returns None or HTTPResponse, which will cut immediately to middleware response phase

    def process_exception(request, exception):
        # catches any exception raised by the view

        # must return `None` (for default exception handling) or `HTTPResponse` (which will skip over any exception handling middleware listed above it, since this is part of the response phase, which is reverse-ordered)

        # NOTE: Django will convert exceptions into responses with a status code if no exception middleware returns a response, so middleware never needs to worry about try/except when calling get_response()

    def process_template_response(request, response):
        # only runs if the response is a TemplateResponse

        # allows for editing the template, context data, or returning a completely different response
```

The middleware order execution is:

1. Request phase (executed in `MIDDLEWARE` listed order):

- request middleware (logic before calling `get_response(request)`)

- view middleware (can short-circuit to template response / response phase)

2. Response phase (executed in `MIDDLEWARE` reverse order):

- exception middleware (first to return an `HTTPResponse`, accounting for reverse order, will short-circuit other exception middleware)

- template response middleware (only if the response returned earlier in the chain is a `TemplateResponse`)

- response middleware (logic after calling `get_response(request)`)

#### Decorators

NOTE: Middleware is applied globally, so logic that only applies to a small subset of views OR requires specific arguments per view, should be decorators.

Django provides some default decorators:

- Auth:
  - `permission_required([permission_name], raise_exception=True)` (should usually set 'raise_exception' to True to avoid continual redirect to login)
  - `login_required`
  - `user_passes_test`
- Caching: `cache_page`, `cache_control`, `never_cache`
- X-frames: `xframe_options_deny/sameorigin/exempt`
- `csrf_exempt`
- Logging Security: `sensitive_variables([optional list of local variables])/sensitive_post_parameters([optional list of names])` (should always be at the top of the decorator chain to make sure that parameters are hidden as well since otherwise they will not be hidden in logs for outer wrapping decorators)
  - Django default views in `auth.views` already set `sensitive_post_parameters()`
- `require_http_methods([request types to restrict to])`

### Templates

- `{{ [var] }}` represent template variables from the passed context, the request object itself, or
  from template tags / cached variables from template tags.

  - Only form of nested variable syntax supported is `var.key` for lookup, which performs the following in order until a match is found:
    - Dictionary lookup: `var["key"]`
    - Attribute lookup: `var.key` (methods or data attributes)
    - List-index lookup: `var[key]` (`key` would need to be an integer here)
  - NOTE: `key` is used as a literal, so you need to use a custom template tag if `key` is meant to
    refer to a context variable for a dynamic lookup key.

- `{% [func] %}` represent template tags (functions).
  - NOTE: functions are called WITHOUT parens and so cannot be passed arguments
  - Return value can be captured as a variable using syntax `{{% [func] as [var] %}}`
- There are two ways to use filters:
  - `{{ [var] | [filter_name]: [arg] | [filter_name2]: [arg] | ... }}` runs the filters on the provided variable
  - `{% filter [filter_name]: [arg] | [filter_naem2]: [arg] | ... %} {% endfilter %}` is a template _tag_ that _runs_ the filters on any rendered content between the tags
  - (the `|` character is referred to as 'pipe', like in UNIX)

#### Templates Inheritance

`{% extends "xxx.html" %}` can be the first line of a template, which allows the template to
override any blocks defined in any of its parent templates.

`{% block [blockname] %} {% endblock [blockname] %}` overrides that block in the parent template
with whatever is placed between the block start and end tags.

`{{ block.super }}` inserts what the parent block would have rendered, and it can be placed
wherever inside the block override, allowing content to precede or follow parent content.

- Inserting child content _within_ a parent block requires breaking up the parent block into
  sub-blocks
  - You can avoid needing to refactor other extended templates by preserving the block and
    inserting sub-blocks within

`{% include "xxx.html" with context_arg1="first" context_arg2="second" %}` includes another template at the location, supporting mixin like behavior

- Can put optional `only` keyword at end to not pass current template context

#### Standard template tags

- `extends/block/load` as seen above
- `{% static [static_asset_url] %}` allows loading from the dir defined by `STATIC_URL` in the
  settings (which search through app dirs, like templates)
  - NOTE: `static` is technically not a standard template tag because it must be loaded first via
    `{% load static %}`
- `{% url [url_path_name] [optional_param_name1=arg1] [optional_param_name2=arg2] %}` returns an domain-relative URL generated according to
  the path in the URLConf with the associated name.
  - `{{ protocol }}` and `{{ domain }}` are accessible in the template to construct absolute URLs in combination with the `url` tag
- `{% if/else/elif %}` skips rendering the interior HTML if the conditional is not true
  - supports `or`, `and`, `not`, and comparison operators like python conditionals
  - `{% endif %}` must end entire 'if' control flow
- `{% for [var] in [list] %}` `{% endfor %}` creates a for loop
  - `{% empty %}` (placed before `endfor`) will render if the list is empty
- `{% with [var]=[expression]%} {% endwith %}` allows using the defined variable within the tags
- `{% debug %}` output a bunch of debugging info if `DEBUG` is true

#### Custom Template Tags

Since functions with arguments cannot be called in templates, you will on-and-off want to create your own custom template tags that allow you to do so:

1. Create `app/templatetags` dir
2. Call `register = template.Library()` at the top of any module in that dir
3. Register custom template tags with `@register.simple_tag` decorator
4. In the template, call `{% load module_name %}` before using any custom template tag
5. Call tag using `tag_function_name arg1 arg2 ...` syntax.

More complex tags can be created with more extensive syntax.

`{% load [template_tag/filter_package] %}` loads all template tags/filters from the specified
package (equivalent to an import statement).

- Also supports `{% load [tag/filter] [tag/filter] from [package] %}` syntax to selectively load.

#### Context Processors

Context processors allow for adding key-values to the view context automatically on all desired requests. They are set in `TEMPLATES`' `OPTIONS.context_processors`.

NOTE: Context processors are ALWAYS invoked unlike middleware, which can be short-circuited, so do NOT rely on middleware to provide required context data.

`RequestContext` is a `Context` that accepts an `HTTPRequest` as its first argument and applies all context processors to itself. Your own defined context passed to a `render()` call by overriding `get_context_data()` will override any matching keys defined in the context processors (unless you are performing custom rendering calls).

### Request/Context Attributes Lifecycle

Context attributes should ONLY be accessed WITHIN templates. They can be WRITTEN anytime before render, but since context processors only add their attributes at render-time, ONLY templates receive the fully-populated context, having passed through middleware and context processors (unless you do significant overriding of render logic).

Therefore, any attributes that need to be accessible OUTSIDE of templates should be set on the REQUEST because the request is accessible throughout the entire lifecycle of request-response handling.

### Forms

Can define form and form field template at different levels:

1. Default form template:

```
from django.forms.renderers import TemplatesSetting

class CustomFormRenderer(TemplatesSetting):
    form_template_name = "form_base.html" # default is "django/forms/div.html"
    field_template_name = "field_base.html" # default is "django/forms/field.html"

FORM_RENDERER = "project.settings.CustomFormRenderer"
```

2. Per-form/field template: set `Form/Field.template_name`
3. Per-view template: set `template_name` in class-based views or pass template for function-based views
4. Per-field template: set `template_name` in form field definition `forms.CharField(template_name="my_custom_template.html")` into the context to render it as a context variable
5. Per-request template (example is for a function-based view):

```
  field_name = form["field_name"]
  context = {"field_name": field_name.render("my_custom_field_template.html")}
  render(request, "full_template.html", context)
```

- NOTE: this doesn't do anything automatically, so you will need to include `{{ field_name }}`
  where you want it in your full template

NOTE: widgets only renders the INPUT elements; they have no knowledge of context data for the field, such as labels, so that needs to be handled yourself

### Statics

Static content is normally hosted on a distinct server or reverse proxy (maybe via nginx) or on a
CDN because serving raw bytes of static content is not what Django/Python is optimized for.

For development, local statics can be served via the development server by adding
`"django.contrib.staticfiles"` to `INSTALLED_APPS` in settings, which will discover statics according to `STATIC_URL` and `STATIC_DIRS`.

## Sessions

User session is accessible by the `session` attribute on the HTTPRequest object received by the view. The browser simply sends the ID for their session in their cookies (usually), and then Django stores all relevant information server-side.

Session cookies are only sent and updates to the DB are only written IF the session is created, deleted, or modified (nested modifications require setting `modified = True` manually)

- This behavior can be changed by changing `SESSION_SAVE_EVERY_REQUEST` in settings

Session data is base64-encoded in the DB.

NOTE: since cookies are a browser concept, if you need integration with mobile apps, then you will need to include token-based auth.

### Cookies

Cookied can also be used alongside sessions, but should only be used when the client code needs
access to the information being stored (in JS, for certain SPAs, etc.).

## Authentication

### Users

ALWAYS create a custom user model to make any desired extension easier later. Simply define a core app, if you don't have one already, to place the model and register it to admin. Then set `AUTH_USER_MODEL` to point at it with snytax `"app_name.UserModelName`

Reusable apps should NOT extend their root (possibly custom) user model since there may be conflicts when importing into other apps with their own extended user models.

The currently actice user model can be retrieved via `django.contrib.auth.get_user_model()`.

When using relationship fields, `settings.AUTH_USER_MODEL` should be used to consistently point to the project's base user model.

#### Out-of-the-box Features

- `Active` flag can be set to false instead of deleting a user.
- `Staff` flag sets whether user can access admin site.
- `Superuser` flag gives ALL permissions to user.
- Users are related to permissions and groups via many-to-many fields (user will have all permissions granted to the groups and to themself)

- Login, Logout, Password Change, and Password Reset functionality is provided by Django built-in views when using standard user models that extend `AbstractUser`.

  - Add `include('django.contrib.auth.urls')` to the URLConf get default routing to:

    ```
    path/ login/ [name='login']
    path/ logout/ [name='logout']
    path/ password_change/ [name='password_change']
    path/ password_change/done/ [name='password_change_done']
    path/ password_reset/ [name='password_reset']
    path/ password_reset/done/ [name='password_reset_done']
    path/ reset/<uidb64>/<token>/ [name='password_reset_confirm']
    path/ reset/done/ [name='password_reset_complete']
    ```

  - Templates are searched for in `project_name/templates/registration/`.
    - If you want to define your templates in an app dir, you need to define your own URLConf URLs, instead of `django.contrib.auth.urls`, subclass the built-in views and set `template_name` in them to your custom location.
  - Can set default login redirect via `LOGIN_REDIRECT_URL` in settings
  - NOTE: Django only allows logout navigation via POST to avoid users getting logged out by only navigating

### Groups

Groups are just a way to apply permissions at a level that can encompass multiple Users. This way,
adding a User to a group is synonymous with giving that User those permissions.

The admin console is the standard way to add/edit groups.

### Permissions

Permissions (default and custom) are stored in the `auth_permission` DB table, and can be assigned to groups or users in their respective many-to-many join tables for permissions.

In views, you can use:

- `PermissionRequiredMixIn` to route a logged out user to login and a logged in user to a 403 Forbidden
- `@login_required @permission_required('app.permission_wanted', raise_exception=True)` because by default `@permission_required` will always route a failed-permission user to the login screen

## Default Middleware & Context Processors

### Middleware

- (3rd-party but always should install) `DebugToolbarMiddleware`: for debugging during Django development

- `SecurityMiddleware`: handles the following (all defined via settings)

  - SSL redirect, SSL redirect host (if set), and SSL redirect exemption paths

  - HSTS headers (seconds, subdomains inclusion, and preload)

  - `'X-Content-Type-Options: nosniff'` header (make sure to have correct content types in your headers)

  - `'Referrer-Policy'` header

  - `'Cross-Origin-Opener-Policy'` header

- `SessionMiddleware` creates/syncs sessions in the DB with the user making the request, sets session ID cookies, and set `request.session`.

- `CommonMiddleware`:

  - Forbids access by User-Agents define in `DISALLOWED_USER_AGENTS` in settings

  - Redirects URLs to add a terminal `/` (default on) and/or prepend `www` (default off)

  - Sets `'Content-Length'` header if missing

- `CsrfViewMiddleware` checks for matching `csrfmiddlewaretoken` on POST requests that have a CSRF cookie, previously set by a `{% csrf_token %}` tag

  - Can be configured additionally with:

    - `CSRF_COOKIE_SECURE`: allows only sending cookie over HTTPS

    - `CSRF_TRUSTED_ORIGINS`: Sets trusted origins for POST calls (`https://*.domain.xxx` to support all subdomains)

    - `CSRF_COOKIE_DOMAIN`: Sets domain/subdomains for which cookie is set (prepend with `.` to support all subdomains)

    - `CSRF_COOKIE_HTTPONLY`: (not necessary because the value must already be readable in the DOM, so this is not more secure against XSS)

    - `CSRF_USE_SESSIONS` (session-dependent cookie, not necessary because of `'Origin'` and `'Referer'` header checks on the request, so CSRF via subdomain cookie setting is mitigated some)

- `AuthenticationMiddleware` gets/sets user associated with the session cookie ID (anonymous if no match) onto the request

  - It does this by fetching the session for the given ID, which contains a user ID (if session is for a logged-in user) that can be used for lookup

- `MessageMiddleware` allows for setting one-time-read messages via `django.contrib.messages.add_message()` that are not cleared until iteration

  - Useful for setting success/error messages that will preserve across a redirect
  - By default uses `FallbackStorage`, which attempts to save messages in a cookie, which is limited to 4KB (2KB to leave space since uswgi restricts headers to 4KB max), and writes any that couldn't fit to the session

- `XFrameOptionsMiddleware` which defaults the header value to `DENY`, so adjust if desired. Should also add your own CSP middleware / header management since `X-Frame-Options` is deprecated.

- (not default, but should add) `XViewMiddleware`: allows for jumping to doc page for any view via bookmarklet.

### Context Processors

- Defaults:
  - `debug`: adds `debug` flag and `sql_queries` for debugging
  - `request`: adds `request`
  - `auth`: adds `user` and `perms`
  - `messages`: adds `messages`

## Email

Django supports creating emails via template as well and provides a wrapper over a SMTP (Simple Mail
Transfer Protocol) _client_, not _server_ (you will need a service like MailChimp for that - why? spam filtering. your emails will get immediately filtered out if not coming from a reputable SMTP server).

## Debugging

`django-debug-toolbar`:

1. Install from PyPI
2. Add`"debug_toolbar"` to `INSTALLED_APPS`
3. Add `path("[debug_prefix]/", include("debug_toolbar.urls"))` to URLConf.
4. Add `"debug_toolbar.middleware.DebugToolbarMiddleware"` to `MIDDLEWARE`.
5. Add `127.0.0.1` to `INTERNAL_IPS` in settings.

## Testing

`python -Wa manage.py test` is the command for running tests.

- `-Wa` is optional, but tells the code to run with warnings, which is useful for deprecation warnings.
- `--verbosity [0-3]` adjusts the output (printing successes instead of just failures, etc.)
- `--parallel [optional number of cores]` runs test classes in parallel (defaults to 1 process per CPU)
- `--keepdb` will prevent DB deletion after tests (note: SQLite uniquely creates in-memory DBs, so nothing will be preserved when using it)
- `--noinput` will not ask about using an existing test DB and will always create a fresh one (useful for CI with possible timeouts)
- can specify specific test to run using module syntax (`package.module.class.method`)
- `--shuffle` allows for running tests in a randomized order to help make sure tests are isolated, BUT the following invariants are always true
  - tests run in order of TestCases (use DB), SimpleTestCases (no DB), TestCases that are set to use DB
  - tests within a test class are always run in the same order

Default `DiscoverRunner` finds any file of format `test*.py` that is importable from the top-level directory using python's `unittest` package, so an `__init__.py` is required if using dirs for your tests.

Can combine with `coverage` package via command `coverage run manage.py test` but needs configuration to be useful since coverage can be very high due to the way models/fields/views/forms are declared with mostly non-instance logic and hook into Django class internals.

NOTE: `CTRL-C` will wait for the current test to finish and exit gracefully, with output regarding all tests that were run AND destroying test databases. Hitting `CTRL-C` again will force exit the tests with no final output AND no deletion of test DBs.

Use `TEST` in `DATBASES` in settings to configure test DB options.

- NOTE: test DBs will use `USER` defined in `DATABASES`, so make sure that user has permission to create new DBs.
- NOTE: DB migrations are always run in order to have test DBs consistent with current DBs.

Test Classes:

- `SimpleTestCase` DB operations not supported unless configured (fast)

  - Contains dummy `Client` that can be used for HTTP requests and view testing

- `TestCase` DB created and torn down for each test class and runs each test in own transaction

- `LiveServerTestCase` if need to use a different client for HTTP requests (Selenium, etc.)

  - `StaticLiveServerTestCase` supports serving statics for tests

### Useful Asserts

-

## Resuable apps

Use `poetry` (or `setuptools` for most general compatibility) to generate a `pyproject.toml` file, which can be used to build your app's package using the python 3rd-party `build` package by calling `python -m build`.

## Production

(Call `python3 manage.py check --deploy` to check for some common production concerns before initial deployment.)

The usual Django production stack consists of the following:

1. **CDN**: purpose is to cache and serve static content at the closest edge server to the user (this can be optional if using a well-configured nginx server).

2. **nginx**: web server to reverse proxy requests coming into your web application; most full-featured and performant form of HTTP handling for lots of connections (optional if using a CDN with something like Whitenoise to cache static assets).

3. **gunicorn**: WSGI, web server gateway interface for Python, which is a pre-forking server (creates multiple workers ahead of time to be ready when requests come in). This provides a few benefits:
   - Thread safety: avoids python threading performance issues since each worker process is running its own Django instance
   - Performance: fully utilize the host's CPU because a Python process is bound to a single core
   - Stability: a crashed worker will be re-spun up automatically
   - Speed: the workers are available ahead of time

4. **django**: application

5. **redis & postgres**: cache and DB

## Extensions

### HTMX
Library for simple HTML-like syntax for AJAX calls on even triggers that replace HTML elements. This allows for a more SPA-like experience when desired.