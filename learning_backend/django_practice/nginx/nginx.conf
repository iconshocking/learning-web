# 'auto' sets value to number of cores (default value is 1)
worker_processes auto;
error_log /log/error.log;

events {
  # Default: 1024
  worker_connections 4096;
}


# no caching configured for this config
http {
  access_log /log/access.log;

  # 'include' imports settings from another file (this is a default that ships with nginx)
  include mime.types;
  default_type application/octet-stream;

  # where template is stored after env substitution
  include /etc/nginx/conf.d/vars.conf;

  # doesn't matter for heroku, since their proxy only supports HTTP/1.1
  http2 on;
  # can support HTTP/2 server push too, which allows pushing additional resources when another resource is requested

  # define the upstream server group
  # (non-HTTP servers can be proxied to but require different directives like 'uwsgi_pass', etc.)
  upstream django {
    # using host name from docker compose
    server django:8000;
    # could define multiple server to support load balancing
    # options:
    # - weight=[number]: weights servers according to how many requests they should receive
    # - backup: only use this server if the others are fully saturated

    # load balancing options:
    # - default: Round Robin even request distribution
    # - 'least_conn': server with least connections
    # - 'ip_hash:'' maps same IP to same server (to assist with sessions, caching, etc.)
    #   - 'server [address] down': preserve server hashes even if one server is taken out of rotation
    #     (to avoid IPs getting new mappings, except for those on the down server)
    # - 'hash' [args]: like 'ip_hash' but with your own defined keys

    # Using something like HAProxy in front of nginx might be better for sticky sessions
    # that don't have the balancing problems of hashing balancing
  }

  # each 'server' is a virtual server
  server {
    # for prod
    server_name static.playground.heroku.cshock.tech;

    listen 80;

    include /etc/nginx/conf.d/static.conf;
  }

  server {
    # default_server designates which virtual server for a specific port should be used if no server_name is matched
    # (default is the first in the file for that port)
    listen 80 default_server backlog=4096;
    # defines the required options for HOST header on request (can use wildcard * and multiple space separated domains
    # server_name myapp.example.com;
    server_name 127.0.0.1, playground.heroku.cshock.tech;

    # redirect to HTTPS if TLS termination proxy header indicates this was a non-TLS request (defined in nginx.template)
    if ($https_redirect_needed = "True") {
      return 301 https://$host$request_uri;
    }

    # 'location @[name]' allows for referencing via name by other directives (instead of URL)

    include /etc/nginx/conf.d/static.conf;

    # '=' for exact matches avoids needing to check other locations and speeds up matching
    location / {
      # do NOT set 'gzip_proxied' for these proxied HTML responses because that makes them vulnerable to BREACH

      # by default, 'proxy_pass' sets Host header to $proxy_host, 'Connection' header to 'close', and clears empty headers
      proxy_pass http://django;
      # Django doesn't need to know it's being proxied, and it makes it easier to set allowable hosts
      proxy_set_header Host $host;
      proxy_pass_request_headers on;

      # don't cache and set private for extra clarity
      add_header Cache-Control "no-store, private";

      # only need these if there is no proxy in front of this (identical to include proxy_params)
      # proxy_set_header X-Real-IP $remote_addr;
      # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      # proxy_set_header X-Forwarded-Host $http_host;
      #
      # replaces the 'Location' header in a proxied server's redirect response to remove the internal network part of the URL
      # ('default' strips 'proxy_pass' value + 'location' value; e.g., '127.0.0.1:8000/index/' becomes 'index/',
      # which is fine because Location header supports relative URLs.)
      proxy_redirect default;

      # 'proxy_buffers' defines the number and size of buffers to use for receiving the proxied response (can also just use defaults)
      # 'proxy_buffer_size' defines the buffer size for the first parts of the response, which can be smaller since it is usually just a header

      # 'proxy_bind' allows for setting the source IP address for connecting to the proxied server
      # (e.g. 'proxy_bind 127.0.0.2' for a different proxy)
    }

    # for production, should increase the max number of connections in the Dockerfile
    # (https://docs.nginx.com/nginx/admin-guide/web-server/serving-static-content/#optimizing-the-backlog-queue))
  }
}
